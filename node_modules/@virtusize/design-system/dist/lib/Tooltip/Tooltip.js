"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _compositionApi = require("@vue/composition-api");

var _Modal = _interopRequireDefault(require("../Modal"));

var _TextView = _interopRequireDefault(require("../TextView"));

var _Tooltip = _interopRequireDefault(require("./Tooltip.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A transient view that appears above other content, usually when a content or element is clicked.
 *
 * @param {string} closeButtonText - The text that shows on on the close button
 * @param {array} componentClass - Add custom classes on the component
 * @param {function} onClose - Callback function that is invoked when Tooltip is closed
 * @param {boolean} open - Open or dismiss Tooltip
 * @param {string} position - Positio of Tooltip relative to the content it is anchored to. Accepted values are top, bottom, left, right. Defaults to bottom.
 * @param {boolean} showCloseButton - Show close button
 * @param {HTMLElement} to - Element where Tooltip will anchor itself to
 */
var Tooltip = (0, _compositionApi.createComponent)({
  name: "Tooltip",
  props: {
    closeButtonText: String,
    componentClass: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    onClose: {
      type: Object
    },
    open: {
      type: Boolean,
      required: true
    },
    position: {
      type: String,
      default: function _default() {
        return "bottom";
      }
    },
    showCloseButton: {
      type: Boolean,
      default: function _default() {
        return true;
      }
    },
    to: {
      type: HTMLElement,
      required: true
    }
  },
  setup: function setup(props, context) {
    var isTooltipOpen = (0, _compositionApi.ref)(false);
    var tooltip;
    var tooltipDOMRect;
    var position = {
      bottom: function bottom(_ref) {
        var _bottom = _ref.bottom,
            left = _ref.left,
            width = _ref.width;
        tooltip.style.cssText = "transform: translate(".concat(left + width / 2 - tooltipDOMRect.width / 2, "px, ").concat(_bottom + window.pageYOffset + 16, "px)");
      },
      top: function top(_ref2) {
        var left = _ref2.left,
            _top = _ref2.top,
            width = _ref2.width;
        tooltip.style.cssText = "transform: translate(".concat(left + width / 2 - tooltipDOMRect.width / 2, "px, ").concat(_top + window.pageYOffset - tooltipDOMRect.height - 16, "px)");
      },
      left: function left(_ref3) {
        var height = _ref3.height,
            _left = _ref3.left,
            top = _ref3.top;
        tooltip.style.cssText = "transform: translate(".concat(_left - tooltipDOMRect.width - 16, "px, ").concat(top + window.pageYOffset + height / 2 - tooltipDOMRect.height / 2, "px)");
      },
      right: function right(_ref4) {
        var height = _ref4.height,
            _right = _ref4.right,
            top = _ref4.top;
        tooltip.style.cssText = "transform: translate(".concat(_right + 16, "px, ").concat(top + window.pageYOffset + height / 2 - tooltipDOMRect.height / 2, "px)");
      }
    };

    var invokeTransitionHook = function invokeTransitionHook(event) {
      event.stopPropagation();
      isTooltipOpen.value = props.open;

      if (!props.open) {
        tooltip.removeEventListener("transitionend", invokeTransitionHook);
      }
    };

    (0, _compositionApi.watch)(function () {
      return props.open;
    }, function _callee(open) {
      var _props$to, toElDomRect;

      return regeneratorRuntime.async(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!open) {
                _context.next = 11;
                break;
              }

              isTooltipOpen.value = open;
              _context.next = 4;
              return regeneratorRuntime.awrap(context.root.$nextTick());

            case 4:
              toElDomRect = (_props$to = props.to) === null || _props$to === void 0 ? void 0 : _props$to.getBoundingClientRect();
              tooltip = context.refs.tooltip;
              tooltipDOMRect = tooltip.getBoundingClientRect();
              position[props.position](toElDomRect);

              if (tooltip) {
                tooltip.addEventListener("transitionend", invokeTransitionHook);
                setTimeout(function () {
                  tooltip.classList.add(_Tooltip.default.open);
                }, 100);
              }

              _context.next = 12;
              break;

            case 11:
              if (tooltip) {
                tooltip.classList.remove(_Tooltip.default.open);
              }

            case 12:
            case "end":
              return _context.stop();
          }
        }
      });
    });
    return function () {
      var _context$slots$defaul, _context$slots;

      return isTooltipOpen.value && (0, _compositionApi.createElement)(_Modal.default, {
        "ref": "modal"
      }, [(0, _compositionApi.createElement)("div", {
        "class": [_Tooltip.default.root, _Tooltip.default[props.position]],
        "ref": "tooltip"
      }, [(_context$slots$defaul = (_context$slots = context.slots).default) === null || _context$slots$defaul === void 0 ? void 0 : _context$slots$defaul.call(_context$slots), props.showCloseButton && (0, _compositionApi.createElement)("div", {
        "class": _Tooltip.default.controls
      }, [(0, _compositionApi.createElement)(_TextView.default, {
        "attrs": {
          "inverse": true,
          "underlined": true
        }
      }, [(0, _compositionApi.createElement)("span", {
        "on": {
          "click": function click() {
            return context.emit("close");
          }
        }
      }, [props.closeButtonText])])])])]);
    };
  }
});
var _default2 = Tooltip;
exports.default = _default2;