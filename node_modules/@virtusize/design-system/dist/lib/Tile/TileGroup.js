"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _compositionApi = require("@vue/composition-api");

var _symbols = require("./symbols");

var _TileGroup = _interopRequireDefault(require("./TileGroup.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Wraps and provides the value, name, and the change event handler to Tiles.
 * @param {array} componentClass - Add custom classes on the component.
 * @param {string} name - Set a reference name for all the children Tiles.
 * @param {boolean} multiple - Enablee multiple selections
 * @param {function} onChange - ChangeEvent handler function
 * @param {boolean} rounded - Render Tiles to be rounded
 * @param {(string|number)} value - The value of the TileGroup
 */
var TileGroup = (0, _compositionApi.createComponent)({
  name: "TileGroup",
  props: {
    componentClass: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    name: String,
    multiple: Boolean,
    onChange: Object,
    rounded: Boolean,
    value: {
      type: [String, Array],
      required: true
    }
  },
  setup: function setup(props, context) {
    var deepCloneArray = function deepCloneArray(array) {
      return JSON.parse(JSON.stringify(array));
    };

    var valuePropClone = function valuePropClone() {
      return Array.isArray(props.value) ? deepCloneArray(props.value) : props.value;
    }; // Keep an internal state of props.value that should also be reactive
    // The reason is Vue's provide is does not track updates so we need to wrap it in a ref


    var state = (0, _compositionApi.ref)(valuePropClone());
    (0, _compositionApi.onUpdated)(function () {
      return state.value = valuePropClone();
    });

    var onChange = function onChange(event) {
      if (Array.isArray(state.value)) {
        var checkbox = event.target;

        if (checkbox.checked) {
          state.value.push(checkbox.value);
        } else {
          state.value.splice(state.value.indexOf(checkbox.value), 1);
        }

        context.emit("change", deepCloneArray(state.value), event);
      } else {
        context.emit("change", event.target.value, event);
      }
    };

    (0, _compositionApi.provide)(_symbols.NAME, props.name);
    (0, _compositionApi.provide)(_symbols.ONCHANGE, onChange);
    (0, _compositionApi.provide)(_symbols.ROUNDED, props.rounded);
    (0, _compositionApi.provide)(_symbols.STATE, state);
    return function () {
      var _context$slots$defaul, _context$slots;

      return (0, _compositionApi.createElement)("div", {
        "class": [_TileGroup.default.root].concat(props.componentClass)
      }, [(_context$slots$defaul = (_context$slots = context.slots).default) === null || _context$slots$defaul === void 0 ? void 0 : _context$slots$defaul.call(_context$slots)]);
    };
  }
});
var _default2 = TileGroup;
exports.default = _default2;