"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _compositionApi = require("@vue/composition-api");

var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _TextView = _interopRequireDefault(require("../TextView"));

var _Ruler = _interopRequireDefault(require("./Ruler.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var INTERVAL = {
  single: 1,
  double: 2
};
/**
 * Select a value by scrolling horizontally.
 * @param {string} interval - Set how many lines would be rendered between ticks.
 *  Acceptable values are single and double.
 *  Single will render 10 lines between ticks. Double renders 10 more. Defaults to single.
 * @param {boolean} inverse - Set the inverted color scheme.
 * @param {function} onChange - Callback function when the value changes.
 * @param {array} ticks - Array of values to be shown as ticks. Can be a mix of strings and numbers.
 * @param {(string|number)} value - Preselect a tick.
 */

var Ruler = (0, _compositionApi.createComponent)({
  name: "Ruler",
  props: {
    interval: {
      type: String,
      default: "single"
    },
    onChange: Object,
    ticks: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    value: [String, Number]
  },
  setup: function setup(props, context) {
    var scrollPane;
    var listenToScroll = (0, _compositionApi.ref)(false);
    var ticks = (0, _compositionApi.computed)(function () {
      // Augment type Tick for padding
      var ticks = _toConsumableArray(props.ticks);
      /**
       * We have to pad the end and/or of the end so that tick values that were passed
       * as a prop will be able to "snap" in the middle
       */


      if (props.interval === "single") {
        ticks.unshift(null);
        ticks = ticks.concat([null, null]);
      }

      if (props.interval === "double") {
        ticks = ticks.concat([null]);
      }

      return ticks;
    });

    var createFillerLines = function createFillerLines() {
      return (0, _compositionApi.createElement)("ul", {
        "class": _Ruler.default.fillerLines
      }, [Array(10).fill(null).map(function () {
        return (0, _compositionApi.createElement)("li");
      })]);
    };
    /**
     * A tick line is 2px wide with a right margin of 4px = 6px
     * 6px * 10 lines = 60px;
     */


    var tickLinesWidth = 60;

    var scrollTo = function scrollTo(tick) {
      var tickIndex = tick ? ticks.value.indexOf(tick) : 0;
      var scrollValue = INTERVAL[props.interval] * tickLinesWidth * (props.interval === "single" ? tickIndex - 1 : tickIndex);

      if (scrollPane.scrollTo) {
        scrollPane.scrollTo({
          left: scrollValue,
          behavior: "smooth"
        });
      } else {
        scrollPane.scrollLeft = scrollValue;
      }
    };

    var onScroll = function onScroll(_ref) {
      var _ref2;

      var currentTarget = _ref.currentTarget;
      var currentTick = Math.floor(((_ref2 = currentTarget) === null || _ref2 === void 0 ? void 0 : _ref2.scrollLeft) / (INTERVAL[props.interval] * tickLinesWidth) + 1);
      var value = ticks.value[currentTick - (props.interval === "single" ? 0 : 1)];

      if (value && value !== props.value) {
        context.emit("change", props.ticks[currentTick - 1]);
      }
    };

    (0, _compositionApi.onMounted)(function () {
      context.root.$nextTick(function () {
        scrollPane = context.refs.scrollPane;
        scrollTo(props.value);
      });
    });
    (0, _compositionApi.onUpdated)(function () {
      return !listenToScroll.value && scrollTo(props.value);
    });
    (0, _compositionApi.watch)(function () {
      return listenToScroll.value;
    }, function (isListening) {
      if (scrollPane) {
        if (isListening) {
          scrollPane.removeEventListener("scroll", onScroll, false);
          scrollPane.addEventListener("scroll", onScroll, false);
        } else {
          scrollPane.removeEventListener("scroll", onScroll, false);
        }
      }
    });
    return function () {
      return (0, _compositionApi.createElement)("div", {
        "class": _Ruler.default.root
      }, [(0, _compositionApi.createElement)(_TextView.default, {
        "attrs": {
          "tag": "p",
          "align": "center",
          "size": "large",
          "weight": "bold",
          "componentClass": [_Ruler.default.value]
        }
      }, [props.value]), (0, _compositionApi.createElement)("div", {
        "class": _Ruler.default.scrollPane,
        "on": {
          "touchmove": function touchmove() {
            listenToScroll.value = true;
          },
          "touchend": (0, _lodash.default)(function () {
            return listenToScroll.value = false;
          }, 500, {
            trailing: true
          })
        },
        "ref": "scrollPane"
      }, [(0, _compositionApi.createElement)("div", {
        "class": _Ruler.default.ruler
      }, [ticks.value.map(function (tick) {
        return (0, _compositionApi.createElement)("div", {
          "class": _Ruler.default.tick
        }, [Array(INTERVAL[props.interval]).fill(null).map(function () {
          return createFillerLines();
        }), tick && (0, _compositionApi.createElement)("span", {
          "class": _Ruler.default.text,
          "on": {
            "click": function click() {
              return tick !== props.value && context.emit("change", tick);
            }
          }
        }, [(0, _compositionApi.createElement)(_TextView.default, {
          "attrs": {
            "size": "large"
          }
        }, [tick])])]);
      })])])]);
    };
  }
});
var _default2 = Ruler;
exports.default = _default2;