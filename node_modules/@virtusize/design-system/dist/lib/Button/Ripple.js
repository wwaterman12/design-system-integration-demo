"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _compositionApi = require("@vue/composition-api");

var _Ripple = _interopRequireDefault(require("./Ripple.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Ripple = (0, _compositionApi.createComponent)({
  name: "Ripple",
  setup: function setup(_, context) {
    var showRipple = (0, _compositionApi.ref)(false);
    var isRippling = (0, _compositionApi.ref)(false);

    var generateRipple = function generateRipple(event) {
      var container, ripple, _container$getBoundin, left, top, width, height, size;

      return regeneratorRuntime.async(function generateRipple$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              showRipple.value = true;
              _context.next = 3;
              return regeneratorRuntime.awrap(context.root.$nextTick());

            case 3:
              container = context.refs.container;
              ripple = context.refs.ripple; // Get the boundaries of the ripple container in respect to device screen

              _container$getBoundin = container.getBoundingClientRect(), left = _container$getBoundin.left, top = _container$getBoundin.top, width = _container$getBoundin.width, height = _container$getBoundin.height; // Determine between width and height is the bigger value

              size = Math.max(width, height); // Create a ripple size equal to twice of the value determined above
              // It has to be a circular ripple that's why we apply it to both width and height

              ripple.style.width = "".concat(size, "px");
              ripple.style.height = "".concat(size, "px"); // Once we get the ripple size, we position it in the center of the mouse click

              ripple.style.left = "".concat(event.clientX - left - size / 2, "px");
              ripple.style.top = "".concat(event.clientY - top - size / 2, "px"); // Once the ripple element is mounted, start the animation

              /* istanbul ignore next */

              setTimeout(function () {
                isRippling.value = true;
              });

            case 12:
            case "end":
              return _context.stop();
          }
        }
      });
    };
    /* istanbul ignore next */


    var resetRipple = function resetRipple(event) {
      showRipple.value = false;
      isRippling.value = false;
    };

    return function () {
      return (0, _compositionApi.createElement)("span", {
        "class": _Ripple.default.root,
        "on": {
          "click": generateRipple
        },
        "ref": "container"
      }, [showRipple.value && (0, _compositionApi.createElement)("span", {
        "class": [_Ripple.default.ripple, isRippling.value ? _Ripple.default.rippling : ""],
        "on": {
          "click": resetRipple,
          "transitionend": resetRipple
        },
        "ref": "ripple"
      })]);
    };
  }
});
var _default = Ripple;
exports.default = _default;